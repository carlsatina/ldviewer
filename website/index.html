<!--EL-device-description-viewer/index.html-->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ECHONET Device Description Viewer</title>
  <link rel="stylesheet" href="libs/themes/default/style.min.css" />
</head>
<body>
  <h1>ECHONET Lite Device Description Viewer</h1>
  <h4><div id="meta-appendix"></div></h4>
  <div id="meta-release"></div><br>
  <div>
    Language:
    <input type="radio" class="radioButton" id="ja" name="lang" checked  onchange="drawTree()">
    <label for="ja" class="radioButtonLabel">ja</label>
    <input type="radio" class="radioButton" id="en" name="lang" onchange="drawTree()">
    <label for="ja" class="radioButtonLabel">en</label>
  </div>
  <h2>Super Class</h2>
  <div id="superclass"></div>
  <h2>Devices</h2>
  <div id="devices"></div>

<script src="libs/jquery/jquery-3.3.1.min.js"></script>
<script src="libs/jstree.min.js"></script>

<script>
const requestURL = 'json/EL_DeviceDescription.json';
const request = new XMLHttpRequest();
let jsonData = {};
let language = "ja";

request.open('GET', requestURL);
request.responseType = 'json';
request.send();
request.onload = function() {
  jsonData = request.response;
  updateJsonData();
  drawMeta();
  drawTree();
}

function drawMeta() {
  const appendix = "Appendix Release: " + jsonData.metaData.release;
  const jsonInfo = "JSON data Version: " + jsonData.metaData.version +
                   ", update: " + jsonData.metaData.date;
  document.getElementById("meta-appendix").textContent = appendix;
  document.getElementById("meta-release").textContent = jsonInfo;
}

function drawTree() {
  language = (document.getElementById("ja").checked) ? "ja" : "en";
  let superClass = createSuperClass();
  let devicesObject = createDevicesObject();

  $.jstree.destroy();
  $.jstree.defaults.core.themes.dots = false;
  $(function() {
    $('#superclass').jstree(superClass);
    $('#devices').jstree(devicesObject);
  });

  // Toggle node:
  $('#superclass').on("changed.jstree", function (e, data) {
    const path = $('#superclass').jstree('get_path', data.selected);
    const is_closed = $('#superclass').jstree('is_closed', data.selected);
    if ((path.length > 1) && is_closed) {
      $('#superclass').jstree('open_all', data.selected);
    } else {
      $('#superclass').jstree('toggle_node', data.selected);                
    }
  });  
  $('#devices').on("changed.jstree", function (e, data) {
    const path = $('#devices').jstree('get_path', data.selected);
    const is_closed = $('#devices').jstree('is_closed', data.selected);
    if ((path.length > 1) && is_closed) {
      $('#devices').jstree('open_all', data.selected);
    } else {
      $('#devices').jstree('toggle_node', data.selected);                
    }
  });  

}

function createSuperClass() {
  let elObject = {
    'core' : {
      'data' : [
        {
          "text": "Super Class",
          "children": []
        }
      ]
    }
  };
  for(let property of jsonData.common.properties) {
    let epc = {
      "text": epcAndDescription(property),
      "children" : [
        accessRule(property),
        createDataFormat(property.data),
        note(property)
      ]
    };
    elObject.core.data[0].children.push(epc);  
  }
  return elObject;
}

function epcAndDescription(property){
  if (property.description) {
    return (property.epc + "&nbsp" + property.description[language] +
      " (from " + property.validRelease.from + " to " + property.validRelease.to + ")");
  } else {
    return "";
  }
}

function accessRule(property){
  return {
    "text": "Access rule",
    "children" : [
      {"text": "Get: " + property.accessRule.get, "icon": "jstree-file"},
      {"text": "Set: " + property.accessRule.set, "icon": "jstree-file"},
      {"text": "Anno: " + property.accessRule.inf, "icon": "jstree-file"}
    ]
  };
}

function createDataFormat(data){
  let dataFormat = { "text": "Data format: " + data.type };
  let dataDescription =[];
  switch (data.type){
    case "enum":
      for (value of data.values) {
        const description = (value[language] ? value[language] : value.number) + 
              (value.readOnly ? " (read only)" : "");
        dataDescription.push({"text": value.edt + "&nbsp" + description, "icon": "jstree-file"});
      }
      break;
    case "number":
      const labelNumber = data.isUnsigned ? "unsigned " : "signed ";
      dataDescription.push({"text": labelNumber + data.size + " byte", "icon": "jstree-file"});
      if (data.unit){
        const label = (language == "ja") ?  "単位 " : "unit  ";
        dataDescription.push({"text": label + data.unit, "icon": "jstree-file"});        
      }
      if (data.minimum !== undefined){
        const label = (language == "ja") ?  "最小値 " : "minimum  ";
        dataDescription.push({"text": label + data.minimum, "icon": "jstree-file"});   
      }
      if (data.maximum){
        const label = (language == "ja") ?  "最大値 " : "maximum  ";
        dataDescription.push({"text": label + data.maximum, "icon": "jstree-file"}); 
      }
      if (data.magnification){
        const label = (language == "ja") ?  "倍率 " : "magnification ";
        dataDescription.push({"text": label + data.magnification, "icon": "jstree-file"}); 
      }
      if (data.coefficient){
        const label = (language == "ja") ?  "係数 " : "coefficient ";
        dataDescription.push({"text": label + data.coefficient, "icon": "jstree-file"}); 
      }
      break;
    case "level":
      dataDescription.push({"text": "base: " + data.base, "icon": "jstree-file"}); 
      dataDescription.push({"text": "maximum: " + data.maximum, "icon": "jstree-file"}); 
      break;
    case "bitmap":
      break;
    case "date-time":
      break;
    case "time":
      break;
    case "raw":
      const a = (data.size == 1) ? " byte " : " bytes ";
      let b = "";
      if (language == "ja") {
        b = (data.isFixedSize) ? "固定長データ": "可変長データ";
      } else {
        b = (data.isFixedSize) ? "fixed size data": "variable size data";
      }
      dataDescription.push({"text": data.size + a + b, "icon": "jstree-file"});
      break;
    // TODO: English
    case "array":
      const labelArrayJa = "要素数 " + (data.isFixedNumberOfItems ? "" : "最大");
      const labelArrayEn = "number of elements " + (data.isFixedNumberOfItems ? "" : "maximum");
      const labelArray = (language == "ja") ? labelArrayJa : labelArrayEn;
      dataDescription.push({"text": labelArray + data.numberOfItems, "icon": "jstree-file"});
      dataDescription.push(createDataFormat(data.data));
      break;
    case "composite":
      for (const element of data.elements) {
        dataDescription.push(createDataFormat(element));
      }
      break;
    case "object":
      for (const element of data.elements) {
        dataDescription.push({"text": element.description[language], "icon": "jstree-file"});
        dataDescription.push(createDataFormat(element.data));
      }
      break;
    default:
  }
  dataFormat.children = dataDescription;
  return dataFormat;
}

function note(property){
  if (property.note) {
    return { "text": "Note: " + property.note[language], "icon": "jstree-file" };
  }
}  

function createDevicesObject() {
  let elObjects = {
    'core' : {
      'data' : []
    }
  };

  for(let device of jsonData.devices) {
    let deviceObject = {
      "text": deviceAndDescription(device),
      "children": []
    };
    for(let property of device.properties) {
      // propertyがjsonData.commonの要素かどうかの確認
      let epc = {
        "text": epcAndDescription(property),
        "children" : [
          accessRule(property),
          createDataFormat(property.data),
          note(property)
        ]
      };
      deviceObject.children.push(epc);  
    }
    elObjects.core.data.push(deviceObject);      
  }
  return elObjects;
}

function deviceAndDescription(device){
  return device.eoj + "&nbsp" + device.description[language] + 
    " (since release: " + device.firstRelease + ")";
}

// fill data for overrided EPCs (EPC: 0x80-0x9F)
// then remove EPCs (EPC: 0x80-0x9F) in case all accessRules are "notApplicable" for cosmetics
function updateJsonData(){
  for(let device of jsonData.devices) {
    let indices = [];
    for(let property of device.properties) {
      const epc = parseInt(property.epc);
      common: {
        if ((epc >= 0x80) && (epc <= 0x9F)) {
          for (commonProperty of jsonData.common.properties) {
            if (commonProperty.epc == property.epc){
              if (property.accessRule){
                if ((property.accessRule.get == "notApplicable") &&
                    (property.accessRule.set == "notApplicable") &&
                    (property.accessRule.inf == "notApplicable")){
                  const index = device.properties.indexOf(property);
                  indices.push(index);
                  break common;
                }
              }              
              if (!property.description){
                property.description = commonProperty.description;
              }
              if (!property.validRelease){
                property.validRelease = commonProperty.validRelease;
              }
              if (!property.accessRule){
                property.accessRule = commonProperty.accessRule;
              }
              if (!property.data){
                property.data = commonProperty.data;
              }
              if (!property.note){
                property.note = (commonProperty.note) ? commonProperty.note : undefined;
              }
            }
          }
        }
      }
    }
    // remove properties of node profile if all accessRule are "notApplicable"
    if (indices.length !== 0){
      indices.sort((a,b) => {return (a < b ? 1 : -1);});
      for (const index of indices) {
        device.properties.splice(index, 1);
      }
    }
  }
  // search remove targets
  let indices = [];
  for (property of jsonData.common.properties) {
    if ((property.accessRule.get == "notApplicable") &&
        (property.accessRule.set == "notApplicable") &&
        (property.accessRule.inf == "notApplicable")){
      const index = jsonData.common.properties.indexOf(property);
      indices.push(index);
    }
  }
  // sort by reverse order
  indices.sort((a,b) => {return (a < b ? 1 : -1);});
  // remove properties
  for (const index of indices) {
    jsonData.common.properties.splice(index, 1);
  }
}

</script></body>
</html>